/* Copyright (c) 2021 vesoft inc. All rights reserved.
 *
 * This source code is licensed under Apache 2.0 License,
 * attached with Common Clause Condition 1.0, found in the LICENSES directory.
 */
#pragma once
#include <gtest/gtest_prod.h>

#include <cstring>
#include <functional>

#include "common/base/Base.h"
#include "common/datatypes/DataSet.h"
#include "common/utils/IndexKeyUtils.h"
#include "interface/gen-cpp2/meta_types.h"
#include "interface/gen-cpp2/storage_types.h"
#include "storage/CommonUtils.h"
#include "storage/exec/IndexNode.h"
namespace nebula {
namespace storage {

/**
 *
 * IndexScanNode
 *
 * reference: IndexNode, IndexVertexScanNode, IndexEdgeScanNode
 *
 * `IndexScanNode` is the base class of the node which need to access disk. It has two derive
 * class `IndexVertexScanNode` and `IndexEdgeScanNode`
 *
 *                   ┌───────────┐
 *                   │ IndexNode │
 *                   └─────┬─────┘
 *                         │
 *                 ┌───────┴───────┐
 *                 │ IndexScanNode │
 *                 └───────┬───────┘
 *             ┌───────────┴────────────┐
 *  ┌──────────┴──────────┐ ┌───────────┴─────────┐
 *  │ IndexVertexScanNode │ │  IndexEdgeScanNode  │
 *  └─────────────────────┘ └─────────────────────┘
 *
 * `IndexScanNode` will access index data, and then access base data if necessary.
 *
 *  Member:
 * `indexId_`               : index_ in this Node to access
 * `partId_`                : part to access.It will be modify while `doExecute`
 * `index_`                 : index defination
 * `indexNullable_`         : if index contain nullable field or not
 * `columnHints_`           :
 * `path_`                  :
 * `iter_`                  : current kvstore iterator.It while be reseted `doExecute` and iterated
 *                            during `doNext`
 * `kvstore_`               : server kvstore
 * `requiredColumns_`       : row format that `doNext` needs to return
 * `requiredAndHintColumns_`: columns that `decodeFromBase` needs to decode
 * `ttlProps`               : ttl properties `needAccesBase_`         : if need
 * `fatalOnBaseNotFound_`   : for debug
 *
 * Function:
 * `decodePropFromIndex`    : decode properties from Index key.It will be called by
 *                            `decodeFromIndex`
 * `decodeFromIndex`        : decode all column in `requiredColumns_` by index
 *                            key-value.
 * `getBaseData`            : get key-value of base data `decodeFromBase`         : get
 *                            all values that `requiredAndHintColumns_` required
 * `checkTTL`               : check data is
 * expired or not
 * -------------------------------------------------------------
 *
 * Path
 *
 * `Path` is the most important part of `IndexScanNode`. By analyzing `ColumnHint`, it obtains
 * the mode(Prefix or Range) and range(key of Prefix or [start,end) of Range) of keys that
 * `IndexScanNode` need to query in kvstore.
 *
 * `Path` not only generate the key to access, but also `qualified` whether the key complies with
 * the columnhint constraint or not.For example, if there is a truncated string index, we cannot
 * simply compare bytes to determine whether the current key complies with the columnhints
 * constraint, the result of `qulified(bytes)` should be `UNCERTAIN` and `IndexScanNode` will
 * access base data then `Path` reconfirm `ColumnHint` constraint by `qulified(RowData)`. In
 * addition to the above examples, there are other cases to deal with.`Path` and it's derive class
 * will dynamic different strategy by `ColumnHint`,`IndexItem`,and `Schema`.All strategy will be
 * added to `QFList_`(QualifiedFunctionList) during `buildKey`, and executed during `qualified`.
 *
 * `Path` whild be reseted when `IndexScanNode` execute on a new part.
 *
 * It should be noted that the range generated by `rangepath` is a certain left included and right
 * excluded interval,like [startKey_, endKey_), although `ColumnHint` may have many different
 * constraint ranges(e.g., (x, y],(INF,y),(x,INF)). Because the length of index key is fixed, the
 * way to obtain **the smallest key greater than 'x'** is to append several '\xFF' after until the
 * length of 'x' is greater than the length of the indexkey.
 *
 *
 * Member:
 * `QFList_`                : all Qualified strategy need to executed during qualified
 * `nullable_`              : if `index_` contain nullable field, `nullable_[i]` is equal to
 *                            `index_->fields[i].nullable`,else `nullable_` is empty
 * `index_nullable_offset_` : Participate in the index key encode diagram
 * `totalKeyLength_`        : Participate in the index key encode diagram
 * `suffixLength_`          : Participate in the index key encode diagram
 * `serializeString_`       : a string express path
 *
 * Index Key Encode:
 * ┌──────┬─────────────┬────────────────┬──────────┬─────────────────────────────────────────┐
 * │ type | PartitionID | Indexed Values | nullable | suffix({vid} or {srcId,rank,dstId})     |
 * │ 1byte|   3 bytes   |    n bytes     | 0/2 bytes| vid.length or vid.length*2+sizeof(rank) |
 * └──────┴─────────────┴────────────────┴──────────┴─────────────────────────────────────────┘
 *                                       │          └───────────────────┬─────────────────────┘
 *                           index_nullable_offset_                 suffixLength_
 * └──────────────────────────────────┬───────────────────────────────────────────────────────┘
 *                              totalKeyLength_
 *
 * Function:
 * `make`                   : construct `PrefixPath` or `RangePath` according to `hints`
 * `qualified(StringPiece)` : qulified key by bytes
 * `qualified(Map)`         : qulified row by value
 * `resetPart`              : reset current partitionID and reset `iter_`
 * `encodeValue`            : encode a Value to bytes
 */

class Path;
class IndexScanNode : public IndexNode {
  FRIEND_TEST(IndexScanTest, Base);
  FRIEND_TEST(IndexScanTest, Vertex);
  FRIEND_TEST(IndexScanTest, Edge);
  // There are too many unittests, so a helper is defined to access private data
  friend class IndexScanTestHelper;

 public:
  IndexScanNode(const IndexScanNode& node);
  IndexScanNode(RuntimeContext* context,
                const std::string& name,
                IndexID indexId,
                const std::vector<cpp2::IndexColumnHint>& columnHints,
                ::nebula::kvstore::KVStore* kvstore)
      : IndexNode(context, name), indexId_(indexId), columnHints_(columnHints), kvstore_(kvstore) {}
  ::nebula::cpp2::ErrorCode init(InitContext& ctx) override;
  std::string identify() override;

 protected:
  nebula::cpp2::ErrorCode doExecute(PartitionID partId) final;
  ErrorOr<Row> doNext(bool& hasNext) final;
  void decodePropFromIndex(folly::StringPiece key,
                           const Map<std::string, size_t>& colPosMap,
                           std::vector<Value>& values);
  virtual Row decodeFromIndex(folly::StringPiece key) = 0;
  virtual nebula::cpp2::ErrorCode getBaseData(folly::StringPiece key,
                                              std::pair<std::string, std::string>& kv) = 0;
  virtual Map<std::string, Value> decodeFromBase(const std::string& key,
                                                 const std::string& value) = 0;
  virtual const std::vector<std::shared_ptr<const meta::NebulaSchemaProvider>>& getSchema() = 0;
  bool checkTTL();
  nebula::cpp2::ErrorCode resetIter(PartitionID partId);
  PartitionID partId_;
  const IndexID indexId_;
  std::shared_ptr<nebula::meta::cpp2::IndexItem> index_;
  bool indexNullable_ = false;
  const std::vector<cpp2::IndexColumnHint>& columnHints_;
  std::unique_ptr<Path> path_;
  std::unique_ptr<kvstore::KVIterator> iter_;
  nebula::kvstore::KVStore* kvstore_;
  std::vector<std::string> requiredColumns_;
  Set<std::string> requiredAndHintColumns_;
  std::pair<bool, std::pair<int64_t, std::string>> ttlProps_;
  bool needAccessBase_{false};
  bool fatalOnBaseNotFound_{false};
};
class Path {
 public:
  enum class Qualified : int16_t { INCOMPATIBLE = 0, UNCERTAIN = 1, COMPATIBLE = 2 };
  using QualifiedFunction = std::function<Qualified(const std::string&)>;
  using ColumnTypeDef = ::nebula::meta::cpp2::ColumnTypeDef;
  Path(nebula::meta::cpp2::IndexItem* index,
       const meta::SchemaProviderIf* schema,
       const std::vector<cpp2::IndexColumnHint>& hints,
       int64_t vidLen);
  virtual ~Path() = default;

  static std::unique_ptr<Path> make(::nebula::meta::cpp2::IndexItem* index,
                                    const meta::SchemaProviderIf* schema,
                                    const std::vector<cpp2::IndexColumnHint>& hints,
                                    int64_t vidLen);
  Qualified qualified(const folly::StringPiece& key);
  virtual bool isRange() { return false; }

  virtual Qualified qualified(const Map<std::string, Value>& rowData) = 0;
  virtual void resetPart(PartitionID partId) = 0;
  const std::string& toString();

 protected:
  std::string encodeValue(const Value& value,
                          const ColumnTypeDef& colDef,
                          size_t index,
                          std::string& key);
  std::vector<QualifiedFunction> QFList_;
  ::nebula::meta::cpp2::IndexItem* index_;
  const meta::SchemaProviderIf* schema_;
  const std::vector<cpp2::IndexColumnHint> hints_;
  std::vector<bool> nullable_;
  int64_t index_nullable_offset_{8};
  int64_t totalKeyLength_{8};
  int64_t suffixLength_;
  std::string serializeString_;
};
class PrefixPath : public Path {
 public:
  PrefixPath(nebula::meta::cpp2::IndexItem* index,
             const meta::SchemaProviderIf* schema,
             const std::vector<cpp2::IndexColumnHint>& hints,
             int64_t vidLen);
  // Override
  Qualified qualified(const Map<std::string, Value>& rowData) override;
  void resetPart(PartitionID partId) override;

  const std::string& getPrefixKey() { return prefix_; }

 private:
  std::string prefix_;
  void buildKey();
};
class RangePath : public Path {
 public:
  RangePath(nebula::meta::cpp2::IndexItem* index,
            const meta::SchemaProviderIf* schema,
            const std::vector<cpp2::IndexColumnHint>& hints,
            int64_t vidLen);
  Qualified qualified(const Map<std::string, Value>& rowData) override;
  void resetPart(PartitionID partId) override;

  inline bool includeStart() { return includeStart_; }
  inline bool includeEnd() { return includeEnd_; }
  inline const std::string& getStartKey() { return startKey_; }
  inline const std::string& getEndKey() { return endKey_; }
  virtual bool isRange() { return true; }

 private:
  std::string startKey_, endKey_;
  bool includeStart_ = true;
  bool includeEnd_ = false;

  void buildKey();
  std::tuple<std::string, std::string> encodeRange(
      const cpp2::IndexColumnHint& hint,
      const nebula::meta::cpp2::ColumnTypeDef& colTypeDef,
      size_t colIndex,
      size_t offset);
  inline std::string encodeString(const Value& value, size_t len, bool& truncated);
  inline std::string encodeFloat(const Value& value, bool& isNaN);
  std::string encodeBeginValue(const Value& value,
                               const ColumnTypeDef& colDef,
                               std::string& key,
                               size_t offset);
  std::string encodeEndValue(const Value& value,
                             const ColumnTypeDef& colDef,
                             std::string& key,
                             size_t offset);
};

/* define inline functions */

}  // namespace storage

}  // namespace nebula
